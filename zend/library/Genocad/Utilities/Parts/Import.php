<?php
class Genocad_Utilities_Parts_Import
{

    public static function processFile($format, $filename, $library) {

        // using this array to pass back all of the messages generated by this function
        $messages = Array();

        $errorMissingReqQueue = "";
        $categoryMissingQueue = "";
        $categoryInvalidQueue = "";
        $duplicatePartsErrorQueue = "";
        $partsCount = 0;
        $formattedImport = Array();
        $returnString = "";

        
        $dbParts = new Application_Model_DbTable_Parts();
        $dbLibraryParts = new Application_Model_DbTable_LibraryParts();
        $dbGrammars = new Application_Model_DbTable_Grammars();
        $grammar = $dbGrammars->find($library->grammar_id)->current();
        $grammarCategories = $grammar->getCategories();

        // read the file into $importData
        $fh = fopen($filename, "r");
        $importData = fread($fh, filesize($filename));
        fclose($fh);

        // get the formatted input based on the $format
        if ($format == 0) {
            $formattedImport = Genocad_Utilities_Parts_Import::readFasta($importData);
        } else {
            $formattedImport = Genocad_Utilities_Parts_Import::readTabDelim($importData);
        }

        foreach ($formattedImport as $part){
            // make sure all the required fields are included and that only valid characters are included (a, c, t, g)
            
            $sequence = strtolower(str_replace(" ", "", $part["sequence"]));
            $sequenceLength = strlen($sequence);
            $sequencePartLength = substr_count($sequence, "a") + substr_count($sequence, "t") + substr_count($sequence, "c") + substr_count($sequence, "g");
            
            if ((strlen($part["partName"]) == 0) OR (strlen($part["categories"]) == 0) OR (strlen($part["sequence"]) == 0)) {
                // The above are all required fields to import parts
                $errorMissingReqQueue .= "Part Name: ".$part["partName"]."  Categories: ".$part["categories"]."  Sequence: ".$part["sequence"].PHP_EOL;
            } elseif ($sequenceLength != $sequencePartLength) {
                $errorMissingReqQueue .= "Part ".$part["partName"]."'s sequence contained invalid characters (not a, c, g, or t)".PHP_EOL;      
            } else {
                
                // check categories next -- if there are no valid categories, then this is also a no-go
                $categories = explode(",", $part["categories"]);
                
                $categoryIn = Array();
                $categoryOut = Array();

                foreach ($categories as $category) {

                    $bFound = false;
                    $duplicate = false;

                    // loop through the grammar categories to see if it exists there
                    foreach ($grammarCategories as $gcat) {
                        if ($gcat->letter == $category) {
                            $bFound = true;
                            $categoryIn[] = $gcat->category_id;
                        }
                    }

                    if (!$bFound) {
                        $categoryOut[] = $category;
                    }

                }

                if (count($categoryIn) == 0) {

                    // No valid categories
                    $categoryMissingQueue .= "Part ".$part["partName"]. "  Listed Categories: " . implode(',', $categoryOut) .PHP_EOL;

                } else {

                    // Check to see if the part already exists within the selected library
                    // first, find the part by sequence for the user
                    $select = $dbParts->select()->where('segment = ?', $sequence)
                                                ->where('user_id = ?', Genocad_Application::getUser()->user_id);
                    $existing_parts = $dbParts->fetchAll($select);

                    //$existing_part = $dbParts->getPartbySequence($sequence);

                    foreach ($existing_parts as $existing_part) {

                        $library_part = $dbLibraryParts->find($library->library_id, $existing_part->id)->current();
    
                        if ($library_part != NULL) {
                            // part already exists for this library
                            $duplicatePartsErrorQueue .= "Part ".$part["partName"]." is a duplicate of an existing part in this library, part ".$existing_part->description.PHP_EOL;
                            $duplicate = true;
                        }

                    }

                    if (!$duplicate) {

                        $dbParts->add($part["partName"], $sequence, $part["description"], array($library->library_id), $categoryIn);
                        $partsCount += 1;
   
                    }

                    if (count($categoryOut) > 0) {
                        $categoryInvalidQueue .= "Part ".$part["partName"]."  Categories: ". implode(',', $categoryOut) .PHP_EOL;
                    }
                }   
            }   
        }
        
        $messages["errorMissingReqQueue"] = $errorMissingReqQueue;
        $messages["categoryMissingQueue"] = $categoryMissingQueue;
        $messages["categoryInvalidQueue"] = $categoryInvalidQueue;
        $messages["duplicatePartsErrorQueue"] = $duplicatePartsErrorQueue;
        $messages["partsCount"] = $partsCount;
        
        return ($messages);
    
    }
    
    public static function readFasta ($importData) {
    // This function translates an imported file to an array so the parts can be imported in a common format.  Certain assumptions are made:
    // 1. That the definition line of the fasta format is in the format >lcl|<identifier>|<categories>
    //    where <identifier> is the name of the part, and <categories> is a comma-delimited list of category letters
    // 2. That a line break separates the lcl line from the sequence
    // 3. The sequence is displayed 80 characters per line
        
        $returnArray = Array();
        $stringEnder = PHP_EOL;
        $returnString = "";
        
        $fastaArray = explode(">", $importData);
        
        foreach ($fastaArray as $element){
           if (strlen(trim($element)) > 0) {
                $lines = explode($stringEnder, $element);
           
                // The first line will contain the elements, the remainder will contain the sequence
                $details = explode("|", $lines[0]);
           
                $partName = $details[1];
                $categories = $details[2];
                $description = ""; // fasta does not include the description
           
                $i = 1;
                $sequence = "";
                for ($i=1; $i < count($lines); $i++) {
                // reassemble the sequence
                    $sequence .= trim($lines[$i]);   
                }
           
                // Add to the returnArray
                array_push($returnArray, Array('partName'=>trim($partName), 'categories'=>trim($categories), 'description'=>trim($description), 'sequence'=>trim($sequence)));
              
           }
        }       
    
        //return $returnString;
        return $returnArray;
    }

    public static function readTabDelim ($importData) {
    // This function reads parts from a tab-delimited format.  Certain assumptions are made:
    // 1. $importData contains all the parts, delimited by end-of-line characters, one part per line
    // 2. The elements within a line are separated by tabs
    // 3. The elements are in the following order: partName, categories, description (if any), sequence
        
        $stringEnder = PHP_EOL;
        $tab = chr(9);
        $returnArray = Array();
        
        $tabdelimArray = explode($stringEnder, $importData);
        
        foreach ($tabdelimArray as $part){
           if (strlen(trim($part)) > 0){
                $details = explode($tab, $part);
                
                // add to returnArray
                array_push($returnArray, Array('partName'=>$details[0], 'categories'=>trim($details[1]), 'description'=>trim($details[2]), 'sequence'=>trim($details[3])));
           }
        }   
            
        return $returnArray;
    }
}